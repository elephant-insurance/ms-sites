package msrqc

import (
	"fmt"
	"net/http"

	enum "github.com/elephant-insurance/enumerations/v2"
	"github.com/elephant-insurance/go-microservice-arch/v2/uf"
)

// TODO: generalize this concept for use in other log types

// Microservice log headers are special data fields that are designed to remain constant across application barriers.

// The rules for these fields are very simple:
// * They should be set for a request context using SetHeaders.
// * Once set for a given context, they may not be overwritten.
// * Setters may be called safely for set values; they will no-op
// * Once set for a given context, any logger using that context will print the set value in all messages.
// * They may only be retrieved in the form of HTTP headers, for the purpose of passing them forward to the next service.

// SetHeaders sets log header values in a context based on received HTTP headers.
// If the required TransactionID field is missing from the input headers, a new one
// is created using appAbbreviation.
// SetHeaders calls logger methods which will not overwrite values already in the context.
func SetHeaders(c Context, inHeaders http.Header, appAbbreviation string) {
	if c == nil {
		return
	}

	txidSet := false

	for k, v := range inHeaders {
		switch k {
		case enum.TXHeader.Brand.HeaderKey:
			if len(v) > 0 && v[0] != `` {
				brand := enum.Brand.ByIDString(v[0])
				if brand != nil {
					SetTransactionBrand(c, &brand.ID)
				} else {
					keyString := (*string)(&enum.TXHeader.Brand.ID)
					rv := fmt.Sprintf(`%v`, v)
					txf := &TXField{
						Key:           *keyString,
						HeaderKey:     enum.TXHeader.Brand.HeaderKey,
						ReceivedValue: &rv,
					}
					NamespaceSet(c, &namespaceKeyConfig, keyString, txf, false)
				}
			}
		case enum.TXHeader.Domain.HeaderKey:
			if len(v) > 0 && v[0] != `` {
				domain := enum.AccountDomain.ByIDString(v[0])
				if domain != nil {
					SetTransactionDomain(c, &domain.ID)
				} else {
					keyString := (*string)(&enum.TXHeader.Domain.ID)
					rv := fmt.Sprintf(`%v`, v)
					txf := &TXField{
						Key:           *keyString,
						HeaderKey:     enum.TXHeader.Domain.HeaderKey,
						ReceivedValue: &rv,
					}
					NamespaceSet(c, &namespaceKeyConfig, keyString, txf, false)
				}
			}
		case enum.TXHeader.ID.HeaderKey:
			if len(v) > 0 && v[0] != `` {
				SetTransactionID(c, v[0])
				txidSet = true
			}
		case enum.TXHeader.Integrator.HeaderKey:
			if len(v) > 0 && v[0] != `` {
				integrator := enum.IntegrationPartner.ByIDString(v[0])
				if integrator != nil {
					SetTransactionIntegrator(c, &integrator.ID)
				} else {
					keyString := (*string)(&enum.TXHeader.Integrator.ID)
					rv := fmt.Sprintf(`%v`, v)
					txf := &TXField{
						Key:           *keyString,
						HeaderKey:     enum.TXHeader.Integrator.HeaderKey,
						ReceivedValue: &rv,
					}
					NamespaceSet(c, &namespaceKeyConfig, keyString, txf, false)
				}
			}
		case enum.TXHeader.Instance.HeaderKey:
			if len(v) > 0 && v[0] != `` {
				SetTransactionInstance(c, v[0])
			}
		case enum.TXHeader.IPAddress.HeaderKey:
			if len(v) > 0 && v[0] != `` {
				SetTransactionIPAddress(c, v[0])
			}
		case enum.TXHeader.Source.HeaderKey:
			if len(v) > 0 && v[0] != `` {
				source := enum.SourceOfBusiness.ByIDString(v[0])
				if source != nil {
					SetTransactionSource(c, &source.ID)
				} else {
					keyString := (*string)(&enum.TXHeader.Source.ID)
					rv := fmt.Sprintf(`%v`, v)
					txf := &TXField{
						Key:           *keyString,
						HeaderKey:     enum.TXHeader.Source.HeaderKey,
						ReceivedValue: &rv,
					}
					NamespaceSet(c, &namespaceKeyConfig, keyString, txf, false)
				}
			}
		case enum.TXHeader.Type.HeaderKey:
			if len(v) > 0 && v[0] != `` {
				SetTransactionType(c, v[0])
			}
		}
	}

	if !txidSet {
		// Special handling for TXID: we want to supply one
		// We add the prefix so that we know the GUID was generated by this app

		uid, _ := uf.GUID.New()
		tid := fmt.Sprintf("%v-%v", appAbbreviation, uid)

		SetTransactionID(c, tid)
	}

	return
}

// HeadersFromContext returns log header values as an HTTP Header map.
func HeadersFromContext(c Context) http.Header {
	rtn := map[string][]string{}
	txfields, err := GetTXFields(c)
	if len(txfields) == 0 || err != nil {
		return nil
	}
	for _, v := range txfields {
		if v.HeaderKey != `` && v.StringValue != nil {
			rtn[v.HeaderKey] = []string{*v.StringValue}
		}
	}

	return rtn
}
